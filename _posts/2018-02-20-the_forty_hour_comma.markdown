---
layout: post
title:      "The Forty Hour Comma"
date:       2018-02-21 02:53:10 +0000
permalink:  the_forty_hour_comma
---


The internet is jam packed with blog posts and articles about all of the grand minutiae of coding but it's hard to observe things like the 'joy of defining functions' written myriad ways without feeling a sense of ever disappearing originality and relevance.

For all of my time and effort, in learning syntax and the nuance of languages -- both computer and natural -- it's sometimes the smallest change that makes all of the difference. An errant comma can, and will eventually, cost you a week's worth of work.

So, needless to say, lessons have been learned. And there are a few strategies to avoid this, but the first, my great lesson in spending the last few weeks thinking that I'm making incredible progress until I make it to the point of frustration where giving up is the least grave of the other options, is to read your error messages and to read them well.

At first they seem cryptic and inspecific, but as deeper learning develops and the more frequently you see the frustrating broken-screen pop up, or your terminal start to seem to lose its own patience, there is a reason. I can now spot many different errors just by the shape of the output; where it's obviously a failing in logic, it's harder than forgetting a closure. I'm pretty happy when I see a fatal error. It used to worry me, but now its met with a swift realization of 'I forgot something'.

And that's a good feeling.

The unnerving errors are those where you need to dig deep. But some errors will tell you what you need to know if you want to spend the time, again working against the possibility of spending forty hours on a simple mistake. Read.

Read read read read read.

The 'where' is present and the 'what', so you can begin by finding which line in which file you've gotten wrong. After that it's up to you to find the 'how' and the 'why'; these are logical issues now. Your error could be anything that you've done and therefore it's up to you to trace back your work, bringing everything out about why this code is your code. It's uncomfortable and refactoring can help, but there is nothing worse than wasting time by ignoring these.

It took a lot of effort for me to feel comfortable tracing bugs, I'm realizing now, because I was never looking at the machine as a machine alone. There is something different about working with logic and a machine -- I've found that the more that I do it, the more I feel that the computer is a tool and that these logs are just logs. There is no ghost in the machine -- nothing magical happens here and nothing that opposes your immediate work. I would consider that growth, first, and there is an endless serving of that beyond this.
